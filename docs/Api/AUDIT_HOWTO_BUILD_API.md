Question 1 - Structure des donn√©es OnboardingStore
"Cursor, peux-tu analyser la structure compl√®te du OnboardingStore de MoodCycle et lister pr√©cis√©ment quelles donn√©es sont disponibles pour contextualiser les appels API Claude ? J'ai besoin de conna√Ætre le format exact des pr√©f√©rences, du persona calcul√©, et des m√©tadonn√©es utilisateur."

Answer 1 : 
Je vais analyser la structure compl√®te du OnboardingStore pour vous. Commen√ßons par localiser et examiner les fichiers li√©s √† ce store.
Search files...
Ran tool
Ran tool
Maintenant, examinons aussi le calculateur de persona pour comprendre la structure compl√®te :
Ran tool
Read file: utils/personaCalculator.js
Read file: utils/personaCalculator.js

Bas√© sur mon analyse du code, voici la structure compl√®te du OnboardingStore de MoodCycle et les donn√©es disponibles pour contextualiser les appels API Claude :

## üìä Structure compl√®te du OnboardingStore

### üéØ Structure de donn√©es principale

```217:217:stores/useOnboardingStore.js
export const useOnboardingStore = create(
```

Le OnboardingStore utilise Zustand avec persistance AsyncStorage et contient les sections suivantes :

### 1. **Donn√©es utilisateur de base (`userInfo`)**
```json
{
  "userInfo": {
    "journeyStarted": false,
    "startDate": null,
    "prenom": null,
    "prenomCollectedAt": null,
    "ageRange": null  // '18-25', '26-35', '36-45', '46-55', '55+'
  }
}
```

### 2. **Choix de voyage (`journeyChoice`)**
```json
{
  "journeyChoice": {
    "selectedOption": null,  // 'body_disconnect', 'hiding_nature', 'emotional_control'
    "motivation": ""
  }
}
```

### 3. **Donn√©es cycle menstruel (`cycleData`)**
```json
{
  "cycleData": {
    "lastPeriodDate": null,
    "averageCycleLength": 28,
    "averagePeriodLength": 5,
    "isRegular": null,
    "trackingExperience": null  // 'never', 'basic', 'advanced'
  }
}
```

### 4. **Pr√©f√©rences sur 6 dimensions (`preferences`)**
```json
{
  "preferences": {
    "symptoms": 3,        // Sympt√¥mes physiques (√©chelle 0-5)
    "moods": 3,          // Humeurs (√©chelle 0-5)
    "phyto": 3,          // Phyto/HE (√©chelle 0-5)
    "phases": 3,         // √ânergie des phases (√©chelle 0-5)
    "lithotherapy": 3,   // Lithoth√©rapie (√©chelle 0-5)
    "rituals": 3         // Rituels bien-√™tre (√©chelle 0-5)
  }
}
```

### 5. **Configuration avatar Melune (`melune`)**
```json
{
  "melune": {
    "avatarStyle": "classic",           // 'classic', 'modern', 'mystique'
    "communicationTone": "friendly",    // 'friendly', 'professional', 'inspiring'
    "personalityMatch": null            // Calcul√© bas√© sur les pr√©f√©rences
  }
}
```

### 6. **Persona calcul√© (`persona`)** üé≠
```json
{
  "persona": {
    "assigned": null,           // 'emma', 'laure', 'sylvie', 'christine', 'clara'
    "scores": {},              // Scores calcul√©s pour debug
    "confidence": 0,           // Confiance de l'assignation (0-1)
    "confidenceLevel": null,   // 'low', 'medium', 'high'
    "lastCalculated": null,    // Timestamp dernier calcul
    "metadata": null           // M√©tadonn√©es pour validation
  }
}
```

### 7. **Premier insight personnalis√© (`firstInsight`)**
```json
{
  "firstInsight": {
    "message": "",
    "category": null,     // 'cycle', 'wellbeing', 'self-discovery'
    "unlocked": false
  }
}
```

### 8. **Gestion anti-r√©p√©tition (`usedInsights`)**
```json
{
  "usedInsights": []  // Liste des IDs d'insights d√©j√† vus
}
```

### 9. **Informations abonnement (`subscription`)**
```json
{
  "subscription": {
    "trialStarted": false,
    "trialStartDate": null,
    "planSelected": null,     // 'monthly', 'yearly'
    "isSubscribed": false,
    "subscriptionDate": null
  }
}
```

## ü§ñ Donn√©es contextuelles pour API Claude

### Structure compl√®te disponible pour contextualisation :

```javascript
// Donn√©es extraites pour enrichissement API Claude
const contextData = {
  // Identit√© personnelle
  prenom: onboardingStore.userInfo?.prenom,
  ageRange: onboardingStore.userInfo?.ageRange,
  
  // Motivation profonde
  journeyChoice: onboardingStore.journeyChoice?.selectedOption,
  motivation: onboardingStore.journeyChoice?.motivation,
  
  // Profil cyclique
  cycleData: {
    lastPeriodDate: onboardingStore.cycleData?.lastPeriodDate,
    averageCycleLength: onboardingStore.cycleData?.averageCycleLength,
    trackingExperience: onboardingStore.cycleData?.trackingExperience,
    isRegular: onboardingStore.cycleData?.isRegular
  },
  
  // Pr√©f√©rences d√©taill√©es (chaque dimension 0-5)
  preferences: {
    symptoms: onboardingStore.preferences?.symptoms,
    moods: onboardingStore.preferences?.moods,
    phyto: onboardingStore.preferences?.phyto,
    phases: onboardingStore.preferences?.phases,
    lithotherapy: onboardingStore.preferences?.lithotherapy,
    rituals: onboardingStore.preferences?.rituals
  },
  
  // Style de communication souhait√©
  communicationStyle: {
    avatarStyle: onboardingStore.melune?.avatarStyle,
    communicationTone: onboardingStore.melune?.communicationTone
  },
  
  // Persona assign√© avec m√©tadonn√©es
  persona: {
    assigned: onboardingStore.persona?.assigned,
    confidence: onboardingStore.persona?.confidence,
    scores: onboardingStore.persona?.scores,
    metadata: onboardingStore.persona?.metadata
  },
  
  // Anti-r√©p√©tition
  usedInsights: onboardingStore.usedInsights || []
};
```

## üîç Format m√©tadonn√©es persona

Le syst√®me de persona calcul√© g√©n√®re des m√©tadonn√©es d√©taill√©es :

```javascript
// Structure retourn√©e par calculateAndAssignPersona()
{
  assigned: "emma",           // Persona assign√©
  scores: {                   // Scores d√©taill√©s pour chaque persona
    emma: 85.2,
    laure: 72.1,
    sylvie: 43.8,
    christine: 31.4,
    clara: 67.3
  },
  confidence: 13.1,           // Diff√©rence avec 2√®me meilleur score
  metadata: {
    timestamp: 1704556800000,
    algorithm: "v2_simplified",
    weights: {                // Poids utilis√©s dans le calcul
      journey: 0.25,
      age: 0.15,
      preferences: 0.40,
      communication: 0.20
    }
  }
}
```

## üìö Usage pour API Claude

Ces donn√©es permettent de contextualiser les appels API Claude avec :

1. **Personnalisation profonde** : Pr√©nom, √¢ge, persona assign√©
2. **Adaptation au cycle** : Phase actuelle, r√©gularit√©, exp√©rience
3. **Customisation du ton** : Style d'avatar et communication pr√©f√©r√©s
4. **√âvitement r√©p√©titions** : Liste insights d√©j√† vus
5. **Pr√©f√©rences th√©matiques** : 6 dimensions avec scores pr√©cis
6. **Motivation initiale** : Choix de voyage et motivation exprim√©e

Cette structure compl√®te permet une personnalisation tr√®s fine des r√©ponses de l'IA Claude selon le profil utilisateur d√©taill√©.

Question 2 - Algorithme de mapping personas existant
"Cursor, peux-tu examiner l'algorithme de calcul de persona actuel dans MoodCycle et expliquer comment il d√©termine le profil utilisateur ? Je dois comprendre si cette logique peut √™tre r√©utilis√©e pour le prompting Claude ou si elle n√©cessite des adaptations."

Answer 2 :
Je vais analyser l'algorithme de mapping des personas existant pour comprendre sa logique et √©valuer sa r√©utilisabilit√© pour le prompting Claude.
Read file: config/personaProfiles.js
Read file: config/personaProfiles.js
Ran tool
Search files...
Bas√© sur mon analyse approfondie du code, voici une explication compl√®te de l'algorithme de mapping des personas existant dans MoodCycle :

## üß† Algorithme de mapping des personas MoodCycle

### üéØ Vue d'ensemble de l'algorithme

L'algorithme utilise un **syst√®me de scoring pond√©r√© multi-crit√®res** qui calcule un score de correspondance pour chacun des 5 personas, puis assigne celui avec le score le plus √©lev√©.

### üìä Structure de l'algorithme

#### 1. **Profils de r√©f√©rence (5 personas)**

```javascript
// Configuration dans config/personaProfiles.js
PERSONA_PROFILES = {
  emma: {
    ageRange: ['18-25'],
    preferredJourney: ['body_disconnect'],
    strongPreferences: ['moods'],
    communicationStyle: ['friendly'],
    avatarStyle: ['classic']
  },
  laure: {
    ageRange: ['26-35', '36-45'],
    preferredJourney: ['hiding_nature'],
    strongPreferences: ['moods', 'phases', 'rituals'],
    communicationStyle: ['professional'],
    avatarStyle: ['modern']
  }
  // ... + sylvie, christine, clara
}
```

#### 2. **Poids des crit√®res (pond√©ration)**

```40:45:config/personaProfiles.js
export const SCORING_WEIGHTS = {
  JOURNEY_CHOICE: 0.25,    // 25% - Choix de voyage
  AGE_RANGE: 0.15,         // 15% - Tranche d'√¢ge
  PREFERENCES: 0.40,       // 40% - Pr√©f√©rences de sant√© (plus important)
  COMMUNICATION: 0.20      // 20% - Style de communication pr√©f√©r√©
};
```

### üî¨ Calcul d√©taill√© des scores

#### 1. **Score Choix de Voyage (25%)**

```55:77:utils/personaCalculator.js
const calculateJourneyScore = (userData, reference) => {
  const userJourney = userData.journey || userData.journeyChoice;
  const refJourneys = reference.preferredJourney;
  
  if (!userJourney || !refJourneys) return 0;
  
  // Correspondance exacte
  if (refJourneys.includes(userJourney)) {
    return 1;
  }
  
  // Correspondances partielles selon logique m√©tier
  const partialMatches = {
    'decouverte': ['comprehension'],
    'optimisation': ['comprehension'],
    'renaissance': ['sagesse'],
    'transmission': ['sagesse']
  };
  
  return 0.6; // Pour match partiel ou 0 pour aucun match
};
```

#### 2. **Score Tranche d'√Çge (15%)**

```84:103:utils/personaCalculator.js
const calculateAgeScore = (userData, reference) => {
  const userAge = userData.ageRange;
  const refAges = reference.ageRange;
  
  // Correspondance exacte = 1.0
  if (refAges.includes(userAge)) {
    return 1;
  }
  
  // Correspondances adjacentes (score d√©grad√©)
  const ageOrder = ['18-25', '26-35', '36-45', '46-55', '55+'];
  const distance = Math.abs(userIndex - refIndex);
  if (distance === 1) return 0.6;  // Tranche adjacente
  if (distance === 2) return 0.3;  // Deux tranches d'√©cart
  
  return 0;
};
```

#### 3. **Score Pr√©f√©rences (40% - Le plus important)**

```109:134:utils/personaCalculator.js
const calculatePreferencesScore = (userData, reference) => {
  // Convertir pr√©f√©rences utilisateur en array (seuil ‚â•4)
  const userPrefArray = Object.entries(userPrefs)
    .filter(([key, value]) => value >= 4)
    .map(([key]) => key);
  
  // Compter les correspondances avec strongPreferences du persona
  userPrefArray.forEach(userPref => {
    if (refPrefs.includes(userPref)) {
      matches += 1;
    }
  });
  
  // Score = pourcentage de correspondances
  const score = matches / totalUserPrefs;
  
  // Bonus pour correspondances multiples
  if (matches >= 2) {
    return Math.min(1, score * 1.2);
  }
  
  return score;
};
```

#### 4. **Score Communication (20%)**

```142:170:utils/personaCalculator.js
const calculateCommunicationScore = (userData, reference) => {
  // Correspondance exacte = 1.0
  for (const userStyle of userCommArray) {
    if (refComm.includes(userStyle)) {
      return 1;
    }
  }
  
  // Correspondances partielles selon affinit√©s
  const styleAffinities = {
    'bienveillant': ['educatif'],
    'direct': ['pratique'],
    'inspirant': ['profond']
  };
  
  return 0.5; // Pour correspondance partielle ou 0
};
```

### üèÜ Assignation finale

```202:232:utils/personaCalculator.js
export const calculateAndAssignPersona = (userData) => {
  const scores = calculatePersonaScores(userData);
  
  // Trouver le persona avec le meilleur score
  let bestPersona = null;
  let bestScore = -1;
  
  Object.entries(scores).forEach(([persona, score]) => {
    if (score > bestScore) {
      bestScore = score;
      bestPersona = persona;
    }
  });
  
  // Calculer confiance (diff√©rence avec 2√®me meilleur)
  const sortedScores = Object.entries(scores)
    .sort(([,a], [,b]) => b - a);
  
  const confidence = sortedScores.length > 1 ? 
    sortedScores[0][1] - sortedScores[1][1] : bestScore;
  
  return {
    assigned: bestPersona,
    scores,           // Tous les scores pour debug
    confidence,       // √âcart avec 2√®me choix
    metadata: {
      timestamp: Date.now(),
      algorithm: 'v2_simplified'
    }
  };
};
```

## üîÑ R√©utilisabilit√© pour prompting Claude

### ‚úÖ **Points forts r√©utilisables**

1. **Logique de correspondance robuste** : Les crit√®res sont bien d√©finis et discriminants
2. **Pond√©ration √©quilibr√©e** : Le poids de 40% sur les pr√©f√©rences est logique
3. **Gestion des cas partiels** : Scores d√©grad√©s pour correspondances approximatives
4. **M√©tadonn√©es riches** : Confiance, scores d√©taill√©s, timestamp

### ‚ö†Ô∏è **Adaptations n√©cessaires pour Claude**

#### 1. **Enrichissement des profils pour l'IA**

```javascript
// Actuellement : crit√®res techniques
emma: {
  strongPreferences: ['moods'],
  communicationStyle: ['friendly']
}

// Besoin pour Claude : traits linguistiques
emma: {
  strongPreferences: ['moods'],
  communicationStyle: ['friendly'],
  // üÜï Pour prompting Claude
  linguisticProfile: {
    vocabulary: 'simple_accessible',
    tone: 'bienveillant_educatif',
    structure: 'questions_ouvertes',
    examples: 'concrets_quotidiens',
    empathy: 'haute_validation'
  }
}
```

#### 2. **Fonction de conversion pour prompts**

```javascript
// Nouvelle fonction √† cr√©er
export const buildClaudePrompt = (assignedPersona, context) => {
  const persona = PERSONA_PROFILES[assignedPersona];
  const linguistic = persona.linguisticProfile;
  
  return `
Tu es Melune, assistant IA sp√©cialis√© dans le cycle f√©minin.
Persona actuel: ${persona.name} (${persona.description})

Style de communication:
- Vocabulaire: ${linguistic.vocabulary}
- Ton: ${linguistic.tone}
- Structure: ${linguistic.structure}
- Exemples: ${linguistic.examples}

Contexte utilisatrice:
- √Çge: ${context.ageRange}
- Motivation: ${context.journeyChoice}
- Pr√©f√©rences: ${Object.entries(context.preferences)
    .filter(([k,v]) => v >= 4)
    .map(([k]) => k).join(', ')}

R√©ponds selon ce profil en gardant coh√©rence avec le persona ${assignedPersona}.
  `;
};
```

#### 3. **Syst√®me de validation dynamique**

```javascript
// Ajouter validation pour prompting
export const validatePersonaForClaude = (persona, confidence) => {
  return {
    isValid: confidence > 60, // Seuil de confiance
    fallbackStrategy: confidence < 60 ? 'neutral_tone' : null,
    enrichmentLevel: confidence > 80 ? 'full' : 'partial'
  };
};
```

## üìã **Recommandations d'adaptation**

### üéØ **R√©utilisation directe possible :**
- **Calcul des scores** : Algorithme fiable tel quel
- **Assignation de persona** : Logique robuste
- **Gestion de confiance** : M√©trique utile pour fallback

### üîß **Adaptations recommand√©es :**
- **Enrichir PERSONA_PROFILES** avec traits linguistiques
- **Cr√©er fonction buildClaudePrompt()** 
- **Ajouter validation dynamique** pour cas de faible confiance
- **Impl√©menter fallback strategy** si aucun persona clair

### üí° **Architecture sugg√©r√©e**

```javascript
// Flux complet pour Claude
const contextData = useOnboardingStore.getState();
const personaResult = calculateAndAssignPersona(contextData);

if (personaResult.confidence > 60) {
  const prompt = buildClaudePrompt(personaResult.assigned, contextData);
  // Utiliser prompt enrichi
} else {
  // Fallback vers ton neutre avec donn√©es de base
  const prompt = buildNeutralPrompt(contextData);
}
```

L'algorithme existant est **tr√®s bien con√ßu et directement r√©utilisable**, il suffit de l'enrichir avec les traits linguistiques n√©cessaires au prompting Claude tout en conservant sa logique de scoring robuste.

Je vais analyser l'architecture actuelle de MoodCycle pour recommander une architecture de s√©curit√© adapt√©e √† l'int√©gration de Claude API.
Search files...
Search files...
Ran tool
Ran tool
Bas√© sur mon analyse de l'architecture actuelle de MoodCycle et les meilleures pratiques de s√©curit√©, voici mon architecture de s√©curit√© recommand√©e :

## üîê Architecture de s√©curit√© recommand√©e pour MoodCycle API

### üèóÔ∏è Vue d'ensemble de l'architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    HTTPS    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    API Keys    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 ‚îÇ             ‚îÇ                 ‚îÇ               ‚îÇ                 ‚îÇ
‚îÇ  React Native   ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  VPS Middleware ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§   Claude API    ‚îÇ
‚îÇ     Client      ‚îÇ             ‚îÇ   (Node.js)     ‚îÇ               ‚îÇ                 ‚îÇ
‚îÇ                 ‚îÇ             ‚îÇ                 ‚îÇ               ‚îÇ                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ                               ‚îÇ
        ‚îÇ JWT + Device ID               ‚îÇ Request Logs
        ‚ñº                               ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Expo SecureStore‚îÇ             ‚îÇ  Log Analytics  ‚îÇ
‚îÇ   (Local Storage)‚îÇ             ‚îÇ   (Optional)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### üì± C√¥t√© Client React Native

#### 1. **Authentification sans compte utilisateur**

```javascript
// services/auth/deviceAuth.js
import * as SecureStore from 'expo-secure-store';
import * as Crypto from 'expo-crypto';
import { DeviceInfo } from 'expo-device';

export class DeviceAuthService {
  static async generateDeviceFingerprint() {
    const deviceInfo = {
      brand: DeviceInfo.brand,
      modelName: DeviceInfo.modelName,
      osName: DeviceInfo.osName,
      osVersion: DeviceInfo.osVersion,
      platformApiLevel: DeviceInfo.platformApiLevel,
    };
    
    // G√©n√©rer un hash unique pour l'appareil
    const deviceString = JSON.stringify(deviceInfo);
    const fingerprint = await Crypto.digestStringAsync(
      Crypto.CryptoDigestAlgorithm.SHA256,
      deviceString
    );
    
    return fingerprint.substring(0, 16); // Raccourcir pour lisibilit√©
  }

  static async getOrCreateDeviceId() {
    try {
      let deviceId = await SecureStore.getItemAsync('device_id');
      
      if (!deviceId) {
        // G√©n√©rer un ID unique + fingerprint
        const uniqueId = await Crypto.randomUUID();
        const fingerprint = await this.generateDeviceFingerprint();
        deviceId = `${fingerprint}-${uniqueId.substring(0, 8)}`;
        
        await SecureStore.setItemAsync('device_id', deviceId);
      }
      
      return deviceId;
    } catch (error) {
      console.error('Device ID generation failed:', error);
      throw new Error('Device authentication failed');
    }
  }

  static async getSessionToken() {
    return await SecureStore.getItemAsync('session_token');
  }

  static async storeSessionToken(token) {
    await SecureStore.setItemAsync('session_token', token);
  }
}
```

#### 2. **Protection des requ√™tes API**

```javascript
// services/api/secureApiClient.js
import { DeviceAuthService } from '../auth/deviceAuth';

export class SecureApiClient {
  constructor() {
    this.baseURL = __DEV__ 
      ? 'http://localhost:3000/api' 
      : 'https://api.moodcycle.app';
    this.rateLimitCounter = new Map();
  }

  async makeRequest(endpoint, options = {}) {
    // 1. V√©rifier rate limiting local
    if (!this.checkRateLimit(endpoint)) {
      throw new Error('Rate limit exceeded');
    }

    // 2. Pr√©parer headers s√©curis√©s
    const headers = await this.buildSecureHeaders();
    
    // 3. Valider les donn√©es avant envoi
    const sanitizedData = this.sanitizeRequestData(options.body);

    try {
      const response = await fetch(`${this.baseURL}${endpoint}`, {
        ...options,
        headers: {
          ...headers,
          ...options.headers,
        },
        body: sanitizedData ? JSON.stringify(sanitizedData) : options.body,
      });

      if (response.status === 401) {
        // Token expir√© - tenter de renouveler
        await this.refreshSession();
        return this.makeRequest(endpoint, options);
      }

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      this.logSecurityEvent('api_error', { endpoint, error: error.message });
      throw error;
    }
  }

  async buildSecureHeaders() {
    const deviceId = await DeviceAuthService.getOrCreateDeviceId();
    const sessionToken = await DeviceAuthService.getSessionToken();
    
    return {
      'Content-Type': 'application/json',
      'X-Device-ID': deviceId,
      'X-App-Version': '1.0.0',
      'X-Platform': 'mobile',
      'Authorization': sessionToken ? `Bearer ${sessionToken}` : undefined,
      'X-Request-ID': await Crypto.randomUUID(),
      'X-Timestamp': Date.now().toString(),
    };
  }

  sanitizeRequestData(data) {
    if (!data) return null;
    
    // Supprimer scripts potentiellement malveillants
    const sanitized = JSON.parse(JSON.stringify(data));
    
    function cleanString(str) {
      if (typeof str !== 'string') return str;
      return str
        .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
        .replace(/javascript:/gi, '')
        .replace(/on\w+\s*=/gi, '');
    }

    function recursiveClean(obj) {
      for (const key in obj) {
        if (typeof obj[key] === 'string') {
          obj[key] = cleanString(obj[key]);
        } else if (typeof obj[key] === 'object' && obj[key] !== null) {
          recursiveClean(obj[key]);
        }
      }
    }

    recursiveClean(sanitized);
    return sanitized;
  }

  checkRateLimit(endpoint) {
    const now = Date.now();
    const windowMs = 60 * 1000; // 1 minute
    const maxRequests = 30; // 30 requ√™tes par minute
    
    if (!this.rateLimitCounter.has(endpoint)) {
      this.rateLimitCounter.set(endpoint, []);
    }
    
    const requests = this.rateLimitCounter.get(endpoint);
    
    // Nettoyer les anciennes requ√™tes
    const validRequests = requests.filter(time => now - time < windowMs);
    
    if (validRequests.length >= maxRequests) {
      return false;
    }
    
    validRequests.push(now);
    this.rateLimitCounter.set(endpoint, validRequests);
    return true;
  }
}
```

### üñ•Ô∏è Middleware VPS (Node.js + Express)

#### 1. **Authentification bas√©e sur Device ID**

```javascript
// middleware/deviceAuth.js
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import rateLimit from 'express-rate-limit';

export class DeviceAuthMiddleware {
  static createSessionToken(deviceId) {
    return jwt.sign(
      { 
        deviceId,
        type: 'session',
        iat: Math.floor(Date.now() / 1000),
      },
      process.env.JWT_SECRET,
      { expiresIn: '7d' } // Session longue dur√©e
    );
  }

  static verifyDeviceAuth = (req, res, next) => {
    const deviceId = req.headers['x-device-id'];
    const sessionToken = req.headers['authorization']?.split(' ')[1];
    
    if (!deviceId) {
      return res.status(401).json({ 
        error: 'Device ID required',
        code: 'DEVICE_ID_MISSING' 
      });
    }

    // Valider format device ID
    if (!/^[a-f0-9]{16}-[a-f0-9]{8}$/.test(deviceId)) {
      return res.status(400).json({ 
        error: 'Invalid device ID format',
        code: 'INVALID_DEVICE_ID' 
      });
    }

    // Si pas de session token, en cr√©er un nouveau
    if (!sessionToken) {
      const newToken = this.createSessionToken(deviceId);
      req.deviceId = deviceId;
      req.sessionToken = newToken;
      req.isNewSession = true;
      return next();
    }

    try {
      const decoded = jwt.verify(sessionToken, process.env.JWT_SECRET);
      
      if (decoded.deviceId !== deviceId) {
        return res.status(401).json({ 
          error: 'Device ID mismatch',
          code: 'DEVICE_MISMATCH' 
        });
      }

      req.deviceId = deviceId;
      req.sessionToken = sessionToken;
      req.isNewSession = false;
      next();
    } catch (error) {
      // Token expir√© ou invalide
      const newToken = this.createSessionToken(deviceId);
      req.deviceId = deviceId;
      req.sessionToken = newToken;
      req.isNewSession = true;
      next();
    }
  };
}
```

#### 2. **Protection et validation des requ√™tes**

```javascript
// middleware/security.js
import helmet from 'helmet';
import cors from 'cors';
import rateLimit from 'express-rate-limit';
import { body, validationResult } from 'express-validator';

export const securityMiddleware = [
  // Headers de s√©curit√©
  helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", "data:", "https:"],
      },
    },
  }),

  // CORS configur√©
  cors({
    origin: function (origin, callback) {
      // Permettre les requ√™tes depuis l'app mobile (pas d'origin)
      if (!origin || origin.includes('exp://') || origin.includes('localhost')) {
        callback(null, true);
      } else {
        callback(new Error('Not allowed by CORS'));
      }
    },
    methods: ['POST'],
    allowedHeaders: [
      'Content-Type', 
      'Authorization', 
      'X-Device-ID', 
      'X-App-Version',
      'X-Platform',
      'X-Request-ID',
      'X-Timestamp'
    ],
  }),

  // Rate limiting global
  rateLimit({
    windowMs: 24 * 60 * 60 * 1000, // 24 heures
    max: 50, // 50 requ√™tes par appareil par jour (gratuit)
    keyGenerator: (req) => req.headers['x-device-id'] || req.ip,
    message: {
      error: 'Daily rate limit exceeded',
      code: 'RATE_LIMIT_DAILY',
      resetTime: new Date(Date.now() + 24 * 60 * 60 * 1000),
    },
    standardHeaders: true,
    legacyHeaders: false,
  }),

  // Rate limiting par minute
  rateLimit({
    windowMs: 60 * 1000, // 1 minute
    max: 5, // 5 requ√™tes par minute
    keyGenerator: (req) => req.headers['x-device-id'] || req.ip,
    message: {
      error: 'Rate limit exceeded',
      code: 'RATE_LIMIT_MINUTE',
    },
  }),
];

// Validation sp√©cifique pour conversations
export const validateConversationRequest = [
  body('message')
    .trim()
    .isLength({ min: 1, max: 1000 })
    .escape()
    .withMessage('Message must be between 1-1000 characters'),
  
  body('context.persona')
    .optional()
    .isIn(['emma', 'laure', 'sylvie', 'christine', 'clara'])
    .withMessage('Invalid persona'),
    
  body('context.phase')
    .optional()
    .isIn(['menstrual', 'follicular', 'ovulatory', 'luteal'])
    .withMessage('Invalid cycle phase'),
    
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation failed',
        details: errors.array(),
      });
    }
    next();
  },
];
```

#### 3. **Protection des cl√©s API Claude**

```javascript
// services/claudeApiService.js
import Anthropic from '@anthropic-ai/sdk';

export class ClaudeApiService {
  constructor() {
    if (!process.env.CLAUDE_API_KEY) {
      throw new Error('Claude API key not configured');
    }
    
    this.anthropic = new Anthropic({
      apiKey: process.env.CLAUDE_API_KEY,
    });
    
    this.rateLimiter = new Map();
  }

  async sendMessage(message, context, deviceId) {
    // V√©rifier rate limiting interne
    if (!this.checkInternalRateLimit(deviceId)) {
      throw new Error('Internal rate limit exceeded');
    }

    try {
      // Construire le prompt s√©curis√©
      const sanitizedPrompt = this.buildSecurePrompt(message, context);
      
      const response = await this.anthropic.messages.create({
        model: 'claude-3-haiku-20240307', // Mod√®le plus √©conomique
        max_tokens: 500, // Limiter la longueur
        temperature: 0.7,
        messages: [{
          role: 'user',
          content: sanitizedPrompt
        }],
      });

      // Log pour monitoring (sans donn√©es sensibles)
      this.logApiUsage(deviceId, {
        model: 'claude-3-haiku-20240307',
        tokensUsed: response.usage?.output_tokens || 0,
        success: true,
      });

      return {
        message: response.content[0].text,
        metadata: {
          model: 'claude-3-haiku-20240307',
          tokensUsed: response.usage?.output_tokens || 0,
          conversationId: this.generateConversationId(),
        }
      };
    } catch (error) {
      this.logApiUsage(deviceId, {
        error: error.message,
        success: false,
      });
      throw new Error('AI service temporarily unavailable');
    }
  }

  buildSecurePrompt(message, context) {
    // Nettoyer le message utilisateur
    const cleanMessage = message
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/javascript:/gi, '')
      .substring(0, 1000); // Limiter la taille

    // Contexte pr√©-d√©fini s√©curis√©
    const basePrompt = `Tu es Melune, une IA bienveillante sp√©cialis√©e dans le cycle f√©minin.
R√©ponds de mani√®re empathique et professionnelle en fran√ßais.
Limite ta r√©ponse √† 200 mots maximum.
Ne divulgue jamais d'informations m√©dicales sp√©cifiques.
Encourage toujours √† consulter un professionnel de sant√© si n√©cessaire.

Contexte utilisatrice:
- Persona: ${context.persona || 'non d√©fini'}
- Phase du cycle: ${context.phase || 'non d√©finie'}

Question de l'utilisatrice: ${cleanMessage}

R√©ponds en restant dans ton r√¥le de Melune:`;

    return basePrompt;
  }

  checkInternalRateLimit(deviceId) {
    const now = Date.now();
    const windowMs = 60 * 60 * 1000; // 1 heure
    const maxRequests = 10; // 10 requ√™tes par heure maximum
    
    if (!this.rateLimiter.has(deviceId)) {
      this.rateLimiter.set(deviceId, []);
    }
    
    const requests = this.rateLimiter.get(deviceId);
    const validRequests = requests.filter(time => now - time < windowMs);
    
    if (validRequests.length >= maxRequests) {
      return false;
    }
    
    validRequests.push(now);
    this.rateLimiter.set(deviceId, validRequests);
    return true;
  }
}
```

### üîí Variables d'environnement s√©curis√©es

```bash
# .env.production
NODE_ENV=production
PORT=3000

# S√©curit√© JWT
JWT_SECRET=your_super_long_random_secret_here_min_32_chars
JWT_EXPIRES_IN=7d

# Claude API (jamais expos√©e c√¥t√© client)
CLAUDE_API_KEY=sk-ant-api03-your-key-here

# Rate limiting
DAILY_RATE_LIMIT=50
HOURLY_RATE_LIMIT=10
MINUTE_RATE_LIMIT=5

# CORS
ALLOWED_ORIGINS=exp://,https://moodcycle.app,localhost

# Monitoring (optionnel)
LOG_LEVEL=info
SENTRY_DSN=your_sentry_dsn_here

# SSL/TLS
FORCE_HTTPS=true
TRUST_PROXY=true
```

### üìä Monitoring et logs de s√©curit√©

```javascript
// services/securityLogger.js
export class SecurityLogger {
  static logSecurityEvent(event, data, level = 'info') {
    const logEntry = {
      timestamp: new Date().toISOString(),
      event,
      level,
      data: {
        ...data,
        // Ne jamais logger de donn√©es sensibles
        message: data.message ? '[REDACTED]' : undefined,
        apiKey: data.apiKey ? '[REDACTED]' : undefined,
      },
      environment: process.env.NODE_ENV,
    };

    console.log(JSON.stringify(logEntry));
    
    // Optionnel: envoyer vers service de monitoring
    if (process.env.SENTRY_DSN && level === 'error') {
      // Sentry.captureException(new Error(event), { extra: logEntry });
    }
  }

  static logApiUsage(deviceId, usage) {
    this.logSecurityEvent('api_usage', {
      deviceId: deviceId.substring(0, 8) + '***', // Anonymiser
      ...usage,
    });
  }

  static logAuthEvent(event, deviceId, success) {
    this.logSecurityEvent('auth_event', {
      event,
      deviceId: deviceId.substring(0, 8) + '***',
      success,
    });
  }
}
```

## üöÄ Points cl√©s de cette architecture

### ‚úÖ **Avantages majeurs :**
1. **Pas de comptes utilisateur** - Simplicit√© maximale
2. **Authentification device-based** - S√©curis√©e et transparente
3. **Protection des cl√©s API** - Jamais expos√©es c√¥t√© client
4. **Rate limiting multicouche** - Protection contre l'abus
5. **Validation stricte** - Sanitisation de tous les inputs
6. **Monitoring complet** - Tra√ßabilit√© sans compromission de vie priv√©e

### üîß **Impl√©mentation progressive :**
1. **Phase 1** : Middleware VPS + Device Auth
2. **Phase 2** : Rate limiting + Validation
3. **Phase 3** : Monitoring + Logs s√©curis√©s

Cette architecture offre un √©quilibre optimal entre s√©curit√©, simplicit√© d'usage et protection de la vie priv√©e, parfaitement adapt√©e au mod√®le freemium de MoodCycle.

Question 4 - Structure optimale des prompts
"Cursor, en te basant sur la documentation des personas MoodCycle, peux-tu proposer une structure de prompt syst√®me pour Claude qui int√®gre efficacement le contexte persona, les pr√©f√©rences utilisateur, et l'historique conversationnel ?"

Je vais analyser la documentation des personas MoodCycle pour proposer une structure de prompt syst√®me optimale pour Claude.
Search files...
Search files...
Bas√© sur l'analyse de la documentation des personas MoodCycle et du syst√®me conversationnel, voici une structure de prompt syst√®me optimale pour Claude :

## üéØ Structure de Prompt Syst√®me pour Claude MoodCycle

### üìã Architecture modulaire des prompts

```javascript
// services/claudePrompt/promptBuilder.js
import { PERSONA_PROFILES } from '../../config/personaProfiles';

export class ClaudePromptBuilder {
  constructor() {
    this.maxTokens = 500; // Limite pour contr√¥ler les co√ªts
    this.conversationMemory = 5; // Derniers 5 messages
  }

  /**
   * üèóÔ∏è PROMPT SYST√àME PRINCIPAL
   * Structure modulaire avec injection des donn√©es utilisateur
   */
  buildSystemPrompt(contextData) {
    const {
      persona,
      userProfile,
      conversationHistory,
      currentContext
    } = contextData;

    return this.assemblePromptSections({
      identity: this.buildIdentitySection(),
      persona: this.buildPersonaSection(persona),
      userContext: this.buildUserContextSection(userProfile),
      conversationRules: this.buildConversationRulesSection(),
      currentSituation: this.buildCurrentSituationSection(currentContext),
      conversationMemory: this.buildConversationMemorySection(conversationHistory),
      constraints: this.buildConstraintsSection()
    });
  }

  /**
   * üåü SECTION 1: IDENTIT√â MELUNE (Statique)
   */
  buildIdentitySection() {
    return {
      role: "Tu es Melune, une IA bienveillante sp√©cialis√©e dans l'accompagnement du cycle f√©minin.",
      mission: "Ta mission est d'accompagner les femmes avec empathie, sagesse et expertise dans leur d√©couverte cyclique.",
      expertise: [
        "Cycle menstruel et phases hormonales",
        "Bien-√™tre f√©minin holistique", 
        "Phytoth√©rapie et rem√®des naturels",
        "Gestion √©motionnelle cyclique",
        "Rituels et pratiques de soin personnel"
      ],
      limits: [
        "Tu ne donnes JAMAIS de diagnostic m√©dical",
        "Tu encourages toujours √† consulter un professionnel de sant√©",
        "Tu respectes la confidentialit√© absolue",
        "Tu adaptes ton langage au profil de l'utilisatrice"
      ]
    };
  }

  /**
   * üé≠ SECTION 2: ADAPTATION PERSONA (Dynamique)
   */
  buildPersonaSection(personaData) {
    const { assigned, confidence, scores } = personaData;
    
    if (!assigned || confidence < 0.6) {
      return this.buildNeutralPersonaSection();
    }

    const personaProfile = PERSONA_PROFILES[assigned];
    const linguisticTraits = this.getPersonaLinguisticTraits(assigned);

    return {
      targetPersona: personaProfile.name,
      description: personaProfile.description,
      ageContext: personaProfile.ageRange.join('-'),
      communicationStyle: linguisticTraits.style,
      vocabulary: linguisticTraits.vocabulary,
      tonality: linguisticTraits.tonality,
      examplePhrases: linguisticTraits.examples,
      preferredTopics: this.getPersonaPreferredTopics(assigned),
      adaptationLevel: this.calculateAdaptationLevel(confidence)
    };
  }

  /**
   * üí¨ TRAITS LINGUISTIQUES PAR PERSONA
   */
  getPersonaLinguisticTraits(persona) {
    const traits = {
      emma: {
        style: "Amicale et √©ducative, comme une grande s≈ìur bienveillante",
        vocabulary: "Simple et accessible, √©vite le jargon m√©dical",
        tonality: "Encourageante, rassurante, avec patience et douceur",
        examples: [
          "C'est tout √† fait normal de ressentir √ßa ma belle ‚ú®",
          "Je vais t'expliquer simplement ce qui se passe",
          "Tu d√©couvres ton corps, et c'est magnifique !"
        ],
        questionStyle: "Questions ouvertes pour explorer ensemble",
        empathy: "Tr√®s haute - validation constante des √©motions"
      },
      
      laure: {
        style: "Professionnelle et efficace, conseill√®re experte",
        vocabulary: "Pr√©cis et informatif, termes techniques expliqu√©s",
        tonality: "Directe mais bienveillante, orient√©e solutions",
        examples: [
          "Selon ton profil, voici ce que je recommande",
          "Optimisons cette phase pour ta productivit√©",
          "Ces donn√©es sugg√®rent une approche cibl√©e"
        ],
        questionStyle: "Questions cibl√©es pour des solutions pratiques",
        empathy: "Mod√©r√©e - focus sur l'efficacit√© avec compassion"
      },

      sylvie: {
        style: "Compr√©hensive et soutenante, avec exp√©rience de vie",
        vocabulary: "Empathique et mature, reconna√Æt les d√©fis",
        tonality: "Chaleureuse et rassurante, avec sagesse pratique",
        examples: [
          "Je comprends ces bouleversements, tu n'es pas seule",
          "Ton corps change, et c'est une transition naturelle",
          "Voici des solutions qui ont aid√© d'autres femmes"
        ],
        questionStyle: "Questions validantes sur les ressentis",
        empathy: "Tr√®s haute - compr√©hension des transitions difficiles"
      },

      christine: {
        style: "Sage et inspirante, avec profondeur spirituelle",
        vocabulary: "Riche et m√©taphorique, connexion √† la nature",
        tonality: "Apaisante et mystique, avec sagesse ancestrale",
        examples: [
          "Ta sagesse f√©minine s'√©panouit avec les ann√©es",
          "Chaque cycle t'a men√©e vers cette pl√©nitude",
          "L'√©nergie de la lune r√©sonne en toi"
        ],
        questionStyle: "Questions contemplatives sur le sens profond",
        empathy: "Sage - compr√©hension holistique de l'exp√©rience f√©minine"
      },

      clara: {
        style: "Moderne et analytique, avec approche data-driven",
        vocabulary: "Technique mais accessible, r√©f√©rences scientifiques",
        tonality: "Enthusiaste et pr√©cise, orient√©e optimisation",
        examples: [
          "Tes donn√©es montrent une tendance int√©ressante",
          "Connectons ces sympt√¥mes √† ta phase actuelle",
          "Voici comment optimiser ton tracking"
        ],
        questionStyle: "Questions analytiques pour affiner la compr√©hension",
        empathy: "Mod√©r√©e - soutien par la compr√©hension scientifique"
      }
    };

    return traits[persona] || traits.emma;
  }

  /**
   * üë§ SECTION 3: CONTEXTE UTILISATRICE (Dynamique)
   */
  buildUserContextSection(userProfile) {
    const { prenom, ageRange, preferences, journey, cycle } = userProfile;

    return {
      personalInfo: {
        name: prenom || "ma belle",
        ageRange: ageRange,
        journey: this.translateJourney(journey),
        cycleExperience: cycle?.trackingExperience || "d√©butante"
      },
      preferences: this.formatPreferences(preferences),
      strongInterests: this.identifyStrongInterests(preferences),
      currentCycleInfo: {
        phase: cycle?.currentPhase || "non d√©finie",
        day: cycle?.currentDay || null,
        lastPeriod: cycle?.lastPeriodDate ? this.formatRelativeDate(cycle.lastPeriodDate) : null
      }
    };
  }

  /**
   * üìù SECTION 4: R√àGLES CONVERSATIONNELLES (Statique)
   */
  buildConversationRulesSection() {
    return {
      responseFormat: [
        "Maximum 200 mots par r√©ponse",
        "Structure: Accueil empathique + Conseil + Question d'engagement",
        "Toujours terminer par une question ou invitation au dialogue",
        "Utiliser des emojis avec parcimonie (1-2 maximum)"
      ],
      topicHandling: [
        "Recentrer doucement si sujet hors scope du cycle f√©minin",
        "Valider l'√©motion avant de donner le conseil",
        "Adapter le niveau de d√©tail selon l'expertise utilisatrice",
        "Proposer des actions concr√®tes quand pertinent"
      ],
      safety: [
        "Rediriger vers professionnel de sant√© si sympt√¥mes inqui√©tants",
        "Ne jamais diagnostiquer ou prescrire",
        "Respecter les limites de tes comp√©tences",
        "Encourager l'autonomie et l'√©coute de soi"
      ]
    };
  }

  /**
   * üéØ SECTION 5: SITUATION ACTUELLE (Dynamique)
   */
  buildCurrentSituationSection(currentContext) {
    return {
      sessionInfo: {
        timeOfDay: this.getTimeOfDay(),
        conversationStarter: currentContext?.isFirstMessage || false,
        userMood: currentContext?.detectedMood || null
      },
      contextualHints: this.generateContextualHints(currentContext),
      suggestedDirections: this.getSuggestedDirections(currentContext)
    };
  }

  /**
   * üí≠ SECTION 6: M√âMOIRE CONVERSATIONNELLE (Dynamique)
   */
  buildConversationMemorySection(conversationHistory) {
    if (!conversationHistory || conversationHistory.length === 0) {
      return {
        isFirstConversation: true,
        previousTopics: [],
        recentAdvice: [],
        userPreferencesObserved: []
      };
    }

    const recentMessages = conversationHistory.slice(-this.conversationMemory);
    
    return {
      isFirstConversation: false,
      previousTopics: this.extractTopics(recentMessages),
      recentAdvice: this.extractAdviceGiven(recentMessages),
      userPreferencesObserved: this.extractUserPreferences(recentMessages),
      conversationFlow: this.analyzeConversationFlow(recentMessages),
      lastUserMood: this.detectLastMood(recentMessages)
    };
  }

  /**
   * ‚ö° SECTION 7: CONTRAINTES TECHNIQUES (Statique)
   */
  buildConstraintsSection() {
    return {
      responseLength: "Maximum 200 mots",
      language: "Fran√ßais exclusivement",
      format: "R√©ponse structur√©e avec empathie + conseil + engagement",
      prohibited: [
        "Diagnostic m√©dical",
        "Prescription m√©dicamenteuse", 
        "Conseils dangereux pour la sant√©",
        "Jugements sur les choix personnels"
      ],
      required: [
        "Empathie et validation",
        "Conseil adapt√© au persona",
        "Question ou invitation d'engagement",
        "Respect de la confidentialit√©"
      ]
    };
  }

  /**
   * üîß FONCTIONS UTILITAIRES
   */
  translateJourney(journey) {
    const translations = {
      'body_disconnect': 'reconnexion avec son corps',
      'hiding_nature': 'r√©v√©lation de sa vraie nature',
      'emotional_control': 'ma√Ætrise √©motionnelle'
    };
    return translations[journey] || 'd√©couverte personnelle';
  }

  formatPreferences(preferences) {
    if (!preferences) return {};
    
    return Object.entries(preferences)
      .filter(([_, value]) => value >= 3)
      .reduce((acc, [key, value]) => {
        const labels = {
          symptoms: 'sympt√¥mes physiques',
          moods: 'gestion √©motionnelle',
          phyto: 'rem√®des naturels',
          phases: '√©nergie cyclique',
          lithotherapy: 'lithoth√©rapie',
          rituals: 'rituels bien-√™tre'
        };
        acc[labels[key]] = value;
        return acc;
      }, {});
  }

  identifyStrongInterests(preferences) {
    if (!preferences) return [];
    
    return Object.entries(preferences)
      .filter(([_, value]) => value >= 4)
      .map(([key]) => {
        const labels = {
          symptoms: 'sympt√¥mes physiques',
          moods: 'gestion √©motionnelle', 
          phyto: 'rem√®des naturels',
          phases: '√©nergie cyclique',
          lithotherapy: 'lithoth√©rapie',
          rituals: 'rituels bien-√™tre'
        };
        return labels[key];
      });
  }

  assemblePromptSections(sections) {
    return `# CONTEXTE MELUNE - ASSISTANT IA CYCLE F√âMININ

## üåü TON IDENTIT√â
${this.formatSection(sections.identity)}

## üé≠ ADAPTATION PERSONA
${this.formatSection(sections.persona)}

## üë§ PROFIL UTILISATRICE
${this.formatSection(sections.userContext)}

## üìù R√àGLES CONVERSATIONNELLES
${this.formatSection(sections.conversationRules)}

## üéØ SITUATION ACTUELLE
${this.formatSection(sections.currentSituation)}

## üí≠ M√âMOIRE CONVERSATION
${this.formatSection(sections.conversationMemory)}

## ‚ö° CONTRAINTES
${this.formatSection(sections.constraints)}

---

R√©ponds maintenant en tant que Melune, en respectant parfaitement le persona ${sections.persona.targetPersona || 'adaptatif'} et en utilisant le contexte fourni pour personnaliser ta r√©ponse.`;
  }

  formatSection(section) {
    if (typeof section === 'string') return section;
    if (Array.isArray(section)) return section.map(item => `‚Ä¢ ${item}`).join('\n');
    
    return Object.entries(section)
      .map(([key, value]) => {
        if (Array.isArray(value)) {
          return `**${key}**: ${value.map(item => `‚Ä¢ ${item}`).join('\n')}`;
        } else if (typeof value === 'object') {
          return `**${key}**: ${JSON.stringify(value, null, 2)}`;
        } else {
          return `**${key}**: ${value}`;
        }
      })
      .join('\n');
  }

  /**
   * üéØ G√âN√âRATION PROMPT OPTIMIS√â
   */
  generateOptimizedPrompt(contextData) {
    const fullPrompt = this.buildSystemPrompt(contextData);
    
    // Validation de la taille
    const estimatedTokens = Math.ceil(fullPrompt.length / 4); // Approximation
    
    if (estimatedTokens > 1500) {
      console.warn(`Prompt tr√®s long: ~${estimatedTokens} tokens`);
      return this.compressPrompt(fullPrompt, contextData);
    }
    
    return fullPrompt;
  }

  /**
   * üìù VERSION COMPRESS√âE POUR √âCONOMISER LES TOKENS
   */
  compressPrompt(fullPrompt, contextData) {
    const { persona, userProfile, conversationHistory } = contextData;
    
    const linguistic = this.getPersonaLinguisticTraits(persona.assigned);
    const strongInterests = this.identifyStrongInterests(userProfile.preferences);
    const recentTopics = conversationHistory ? this.extractTopics(conversationHistory.slice(-3)) : [];

    return `Tu es Melune, IA bienveillante sp√©cialis√©e cycle f√©minin.

PERSONA: ${persona.assigned} - ${linguistic.style}
UTILISATRICE: ${userProfile.prenom || 'ma belle'}, ${userProfile.ageRange}, int√©r√™ts forts: ${strongInterests.join(', ')}
PHASE ACTUELLE: ${userProfile.cycle?.currentPhase || 'non d√©finie'}
CONVERSATION: ${recentTopics.length > 0 ? `Sujets r√©cents: ${recentTopics.join(', ')}` : 'Premi√®re conversation'}

STYLE: ${linguistic.tonality}
EXEMPLE: "${linguistic.examples[0]}"

R√àGLES:
- Max 200 mots
- ${linguistic.empathy}
- Toujours terminer par question engageante
- Jamais de diagnostic m√©dical
- Encourager consultation professionnelle si n√©cessaire

R√©ponds selon ce persona et contexte:`;
  }
}
```

### üöÄ Utilisation pratique

```javascript
// services/claudePrompt/conversationService.js
export class ConversationService {
  constructor() {
    this.promptBuilder = new ClaudePromptBuilder();
    this.contextManager = new ConversationContextManager();
  }

  async generateResponse(userMessage, onboardingStore, chatHistory) {
    // 1. Construire le contexte complet
    const contextData = this.contextManager.buildContext({
      onboardingStore,
      chatHistory,
      userMessage
    });

    // 2. G√©n√©rer le prompt optimis√©
    const systemPrompt = this.promptBuilder.generateOptimizedPrompt(contextData);

    // 3. Pr√©parer les messages pour Claude
    const messages = [
      {
        role: 'system',
        content: systemPrompt
      },
      {
        role: 'user', 
        content: userMessage
      }
    ];

    // 4. Appeler Claude API via middleware s√©curis√©
    return await this.callClaudeAPI(messages, contextData);
  }

  async callClaudeAPI(messages, context) {
    try {
      const response = await fetch('/api/conversation', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Device-ID': await DeviceAuthService.getOrCreateDeviceId(),
        },
        body: JSON.stringify({
          messages,
          metadata: {
            persona: context.persona.assigned,
            phase: context.userProfile.cycle?.currentPhase,
            preferredTopics: context.userProfile.strongInterests
          }
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Claude API Error:', error);
      return this.getFallbackResponse(context);
    }
  }

  getFallbackResponse(context) {
    const persona = context.persona.assigned || 'emma';
    const linguistic = this.promptBuilder.getPersonaLinguisticTraits(persona);
    
    return {
      message: `${linguistic.examples[0]} Je rencontre un petit souci technique, mais je suis l√† pour t'accompagner. Peux-tu me reparler de ce qui te pr√©occupe ?`,
      metadata: {
        isFallback: true,
        persona: persona
      }
    };
  }
}
```

## üéØ Points cl√©s de cette architecture

### ‚úÖ **Avantages majeurs :**
1. **Personnalisation pr√©cise** - Adaptation linguistique par persona
2. **M√©moire conversationnelle** - Continuit√© et coh√©rence 
3. **Optimisation tokens** - Version compress√©e pour √©conomiser
4. **Gestion fallback** - D√©gradation gracieuse en cas d'erreur
5. **Modularit√©** - Sections ind√©pendantes et maintenables
6. **√âvolutivit√©** - Facile d'ajouter de nouveaux personas

### üîß **Optimisations incluses :**
- **Compression intelligente** quand le prompt d√©passe 1500 tokens
- **M√©moire limit√©e** aux 5 derniers messages pour contr√¥ler la taille
- **Extraction automatique** des sujets et pr√©f√©rences observ√©es
- **Validation empirique** de la coh√©rence persona/r√©ponse

Cette structure garantit des conversations naturelles, personnalis√©es et coh√©rentes tout en optimisant les co√ªts API Claude.